<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
    //栗1：
    /*fn1();
    function fn1(){
        alert(1);
    }

    fn2();
    var fn2= function () {//不能前置
        alert(2);
    };*/

    //栗2：

    function Foo(){
        fn1 = function () {
            console.log(1);
        };
        return fn1;
    }
    Foo.fn1 = function () {
        console.log(2);
    };
    var fn1= function () {
        console.log(3);
    };
    Foo.prototype.fn1= function () {
        console.log(4);
    };
    Foo.__proto__.fn1= function () {
        console.log(5);
    };
//  Foo()();//1
    //fn1();//3
    //命名空间的优先级大于__proto__，所以输出2而不是4
//  Foo.fn1();//2
    //Foo().fn1();//2
//  Foo.prototype.fn1()//4

    //栗3
    /*
    var fn = "abc";
    function fn(){
        alert(1);
    }
	//函数变量会提升至最前方，给覆盖了    
    fn();//出错
    */

    //栗5
   /*function Foo(){
       getName = function(){//全局函数
           console.log(1);
        };
        return this;//return this,这就将调用方法的对象传给调用链上的下一个方法。
    }
    Foo.getName = function(){//命名空间
        console.log(2);
    };
    Foo.getName.prototype.name= function () {
        console.log('yrd');
    };
    Foo.prototype.getName = function(){
        console.log(3);
    };
    var getName = function(){
        console.log(4);
    };
    function getName(){
        console.log(5);
    };
    Foo.getName();              //2 命名空间
        console.log('I*');
    getName();                  //4 变量名覆盖了函数名
        console.log('II*');
    Foo().getName();            //1 【链式调用】:Foo()执行之后(把getName重新定义了)，【再回到全局】调用getName()，
        console.log('III*');
    getName();                  //1 这时候getName已经重新赋值了
        console.log('IV*');
    new Foo.getName();          //2,开辟了一个【Foo.getName实例对象】，并执行了Foo.getName()
        console.log('V*');
    new Foo.getName().name();   //2,yrd
        console.log('VI*');
    new Foo().getName();        //3  开辟了一个【Foo实例对象】，调用Foo.prototype.getName()
        console.log('VII*');
    new new Foo().getName();    //3 开辟了一个【new Foo().getName实例对象】，并执行了new Foo().getName()
        console.log('VIII*');
    */
    /*
    最后一个，其实就相当于先执行  b = new Foo()，再执行new b.getName()，所以结果还是对象，
    虽然b.getName() 与 Foo.getName()【函数内容】是一样的，
    但new b.getName()与 new Foo.getName()是【不一样的】。
    */

    //栗6：编译与预编译
    /*
     【预编译期】I：定义变量，定义函数、开辟函数空间(确定函数作用域)；
     【编译期】II：变量赋值，执行代码
     */
    //【6.1】
    /*
    var a=0;//I:var a(声明外部变量);II:a=0(赋值)；
    function test(){//I:声明函数、开辟函数空间
        console.log(a);//II:寻找内部的a，发现有声明，但未赋值，undefined;
        var a=1;//I:var a(声明内部变量);
        console.log(a);
    };
    test();//undefined 1;
    */
    //【6.2】
    /*
    var a=0;//I:var a(声明外部变量);II:a=0(赋值)；
    function test(){//I:声明函数、开辟函数空间
        console.log(a);//II:寻找内部的a，发现未声明，寻找外部a=0
        a=1;//II:a=1,重新赋值;
        console.log(a);//II:a=1
    };
    test();//0,1
    */
    //【6.3】
    /*
    function hello(){//:I第一次声明
        alert(1);
    }
    hello();//2 II:执行最后一次声明的函数
    function hello(){//I:第二次声明覆盖第一次
        alert(2);
    }
    hello();//2
    */
    //【6.4】
    /*
    f1();//1
    function f1(  ){//I:声明f1是个函数，可以提前调用
        alert(1);
    };
    //f2();//报错,f2只是个变量,不能提前调用
    var f2=function(  ){//I:声明var f2；f2只是个变量
        alert(1);
    };
    f2();//1

     function ttt(){
	     return xx();//return 后的代码停止执行。
	     // 但return【调用函数】，可以【无视函数位置】
	     function xx(){
	     	return (alert (221))
	     }
     }
     alert(ttt());
    */






    //【待处理】????????

    /*for(var i=1;i<=3;i++){
        setTimeout(function(){
            console.log(i);//事件处理器在线程空闲之前不会运行。
        },0);
    };
    for(let i=1;i<=3;i++){
        setTimeout(function(){
            console.log(i);//let 声明了一个块级域的局部变量，并且可以给它一个初始化值。
        },0);
    };
    for(var i=1;i<=3;i++){
        (function (a) {
            setTimeout(function(){
                console.log(a);//
            },0);
        })(i);
    };*/

</script>
</body>
</html>