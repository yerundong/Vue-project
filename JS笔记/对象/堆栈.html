<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    堆(heap)、栈(stack)是两种数据结构。
    在单片机应用中，堆栈是个特殊的【存储区】，主要功能是：暂时存放【数据和地址】，通常用来保护断点和现场。

    要点：堆：队列优先,先进先出（FIFO—first in first out）（两个孔）。
    栈：先进后出(FILO—First-In/Last-Out)（1个孔）。

    栈：使用的是【一级缓存】， 他们通常都是被调用时处于存储空间中，调用完毕【自动立即释放】，存取速度比堆要快。
    堆：则是存放在二级缓存中，生命周期由虚拟机的【垃圾回收算法】来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

    栈是用来【存原始值】得，堆是用来【存引用值】的。栈里面值的复制是会覆盖的，
    但是堆里面对象的复制，是用【指针】来说的。

    【任何方法】都【无法改变】一个基本类型的值（原始值）。
    引用类型的值（引用值）是【可变的】

    JS中对象分为【基本类型】和【引用类型】，基本类型存放在【栈内存】，引用类型存放在【堆内存】。

    其实究其根本，所谓【引用类型】，还是由【基本类型构成】的。

    堆为自动分配的内存空间，它由系统自动释放；而栈则是动态分配的内存，大小不定也不会自动释放。

    【基本类型】：存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。
    5种基本数据类型有Undefined、Null、Boolean、Number 和 String，它们是直接按值存放的，所以可以【直接访问】。
    【引用类型】：存放在堆内存中的对象，变量实际保存的是一个【指针】，这个指针指向另一个位置。每个空间大小
    不一样，要根据情况开进行特定的分配。当我们需要访问引用类型（如对象，数组，函数等）的值时，首先从栈中获
    得该对象的【地址指针】，然后再从堆内存中取得所需的数据。

    null值表示一个空对象指针，null不能添加自定义属性。


    <script>
//栗1：传值与传址
        /*
        var arr = [1,2,3,4,5];
        var b = arr;//arr是引用类型，赋值给b，是把栈中的地址指针赋给b,arr与b都是引用类型，且地址指针一样
        var c = arr[0];//把arr里的数字赋给c，c是number的基本类型
        //b=[1,2,3,4,5];
        //c=1;
        //改变数值
        a[1]="*";//arr修改的时候，会根据【地址】寻回到arr堆中修改值，同理，b修改时也一样。
        b[4] = "#";//只有[引用类型]的才能发生关联，基本类型不能关联
        c = "@";//c则直接在栈中修改，并且不能指向a堆内存中。
        console.log(b);//1, "*", 3, 4, "#"
        console.log(arr);//1, "*", 3, 4, "#"
        */
//栗2：浅拷贝与深拷贝
//        浅拷贝：即栗1中的直接赋值，二者指向同一块内存地址，只改变时父对象与子对象发生关联【传址】
//        深拷贝：利用遍历，将父对象中的值赋给子对象，而不是传址，不会发生关联，如下：【传值】
        /*
        var a = {
            key:1
        };
        var b = [1];
        //对象或数组深度拷贝方法
        function Copy(p) {
            if(typeof p == 'object'&&p.constructor==Array){
            	var c=[];
            	for (var i in p){
	                c[i] = p[i];
	            }
	            return c;
            }else if(typeof p == 'object'&&p.constructor==Object){
            	var c={};
            	for (var i in p){
	                c[i] = p[i];
	            }
	            return c;
            }else{
            	throw '请输入一个数组或对象'
            }
        }
        //对象
        var c = Copy(a);
        a = {//改变父对象中的值，而子对象不会发生改变
            key:2
        };
        //console.log(a);
        //console.log(c);
        //数组
        var d = Copy(b);
        b = [2];//改变父对象中的值，而子对象不会发生改变
        //console.log(b);
        //console.log(d);
        */
//栗3：
        /*
        var s1 = 1;
        var s2 = 1;
        var p1 = {};//引用类型不仅需要比较类型，值，还要比较地址指针
        var p2 = {};//新开辟一个内存空间
        alert(s1===s2);//true
        alert(p1==p2);//false
        */

//栗4：
		/*
        //原始值是【任何方法】都无法改变
        function change1(a){
            a = 0;
        }
        var m = 5;
        change1(m);
        //alert(m);//5
        
        //引用值是可以改变的
        function change2(a){
            a[0] = null
        }
        var m = [1,2,3];
        change2(m);
        //alert(m);//
		*/
        //引用值是可以改变的，因为传递的是地址
        /* function change(obj)
         {
         var c = obj.a;
         obj.a = obj.b;
         obj.b = c;
         }
         var obj =
         {
         a:3,
         b:4,
         };
         change(obj);
         alert(obj.a + "-" + obj.b);// 4-3 交换成功*/
    </script>
</body>
</html>