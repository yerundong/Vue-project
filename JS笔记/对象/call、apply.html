<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="../jquery-1.11.2.min.js" type="text/javascript" charset="utf-8"></script>
    <script>
		/*
		call 和 apply 都是为了改变【某个函数运行时】的 【context】，即【上下文】而存在的，换句话说，
		就是为了【动态改变函数体内部 this的指向】而存在的。因为 JavaScript 的函数存在【定义时上下文】和【运行时上下文】以及
		【上下文是可以改变的】这样的概念。二者的作用【完全一样】，只是【接受参数的方式】不太一样。
		应用于：Function 对象 
		用法：
		function fn(参数1，参数2...){...};
		fn.call(obj,参数1，参数2...);==>call 需要把参数按顺序传递进去
		fn.aplly(obj,[参数1，参数2...]);==>apply 则是把参数放在数组里。
		当你的【参数是已知明确数量】时，用 call，而不确定的时候，用 apply，然后把参数 push进数组传递进去。
		当参数数量不确定时，函数内部也可以通过 【arguments】这个数组来遍历所有的参数。
		*/
//*************【例子1】
		function fn1(arg1, arg2) {
			//console.log(arguments)
			console.log('=========fn1===========')
			console.log(this)
//			this(arg1, arg2)
			console.log(arg1+arg2)
		};
		function fn2(arg1, arg2) {
			console.log('=========fn2===========')
			console.log(arg1*arg2)
		};
		//this指向fn1本身
//		fn1.call(this,2,3);//5
		//fn1.apply(this,[2,3]);//5
		
		//this指向fn2
//		fn1.call(fn2,2,3);//5
//		fn1.apply(fn2,[2,3]);//5
//*************【例子2】	
		//当一个object没有某个方法或属性，但是其他的有，我们可以借助call或apply用【其它对象的方法或属性】来操作。
		var obj1 = {
			name1:'name1',
			fn1:function  () {
				console.log('fn1==>'+this.name1)
				console.log('fn1==>'+this.name2)
			}
		};
		var obj2 = {
			name2:'name2',
			fn2:function  () {
				console.log('fn2==>'+this.name1)
				console.log('fn2==>'+this.name2)
			}
		};
		//obj1执行【自己的方法】来调用【其他对象的属性】
//		obj1.fn1.call(obj2);//fn1==>name2  执行的是fn1，但this指向obj2，调用的是obj2.name2
		//obj1执行【其他对象的方法】来调用【自己的属性】
//		obj2.fn2.call(obj1);//==》fn2==>name1 执行的是fn2，但this指向obj1，调用的是obj1.name

//*************【例子3】：组合继承	
//      function Fun1(arg){
//          this.arr =[1,2,3];
//          this.fn1 = function () {
//          	console.log('fn1==>'+arg)
//          }
//      }
//      Fun1.prototype.fn2 = function(){
//          console.log('fn2==>'+this.arr);//这里不能获得参数arg
//      };
//      var fun1 = new Fun1(777);
//      console.log(fun1)
//      fun1.fn1();
//      
//      function Fun2(arg){
//          Fun1.call(this,arg);//Fun1中的this指向Fun2，Fun1继承Fun2中所有的属性和方法（不包括prototype里的）
//      }
//      Fun2.prototype = new Fun1();//Fun1原型继承Fun2原型
//      //Fun2.prototype = new Fun1(888);//这样则把【fn1的所有属性】都继承到【fun2的原型】下，不需要使用call,是两种不同的继承方式
//      
//      //这样fun2就完成把fun1所有的属性和方法继承过来了
//      var fun2 = new Fun2(888);
//      console.log(fun2);
//      fun2.fn2();
//*************【例子4】：组合继承中的应用	
		var arr1 = [1,2,3];
		var str = '123456';
		var obj1 = {
			'length':3,
			'a':'5',
			'b':'6'
		}
		
		var str1 = str.slice(1,2);
		function func (a,b) {
			console.log($.type(arguments));//object 类数组(array-like)
			console.log(arguments);
			var arg =  Array.prototype.slice.call(arguments);
			console.log($.type(arg));//数组
			console.log(arg);
		}
		//func (2,9)
		arr1.splice(1,0,parent);
//		console.log(arr1);
    </script>
</head>
<body>

</body>
</html>